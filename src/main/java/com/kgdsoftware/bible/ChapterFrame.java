/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.kgdsoftware.bible;

import com.kgdsoftware.bible.model.Book;
import com.kgdsoftware.bible.model.Chapter;
import com.kgdsoftware.bible.model.LastChapter;
import com.kgdsoftware.bible.model.Setting;
import com.kgdsoftware.bible.model.Verse;
import com.kgdsoftware.bible.model.Version;
import java.awt.Color;
import java.awt.Font;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.Document;
import javax.swing.text.Element;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;

/**
 *
 * @author henriwarren
 */
public class ChapterFrame extends javax.swing.JFrame implements
        GetVerses.Finished,
        ChaptersDialog.ChapterSelected,
        GetNotesForChapter.Finished,
        GetNote.Finished {

    private static final AttributeSet sVerseText;
    private static final AttributeSet sVerseWithoutNote;
    private static final AttributeSet sVerseWithNote;

    static {
        SimpleAttributeSet parent = new SimpleAttributeSet();
        parent.addAttribute(StyleConstants.Family, Setting.getString("FontName", "Lucida Grande"));
        parent.addAttribute(StyleConstants.FontSize, Setting.getInt("FontSize", 18));
        int bold = Setting.getInt("FontStyle", Font.BOLD);
        parent.addAttribute(StyleConstants.Bold, (bold == Font.BOLD) ? true : false);

        StyleContext sc = StyleContext.getDefaultStyleContext();
        sVerseText = sc.addAttribute(parent, StyleConstants.Foreground, Color.black);
        sVerseWithNote = sc.addAttribute(parent, StyleConstants.Foreground, Color.blue);
        sVerseWithoutNote = sc.addAttribute(parent, StyleConstants.Foreground, Color.red);
    }

    private final Executor mExecutor;
    private int mVersionId;
    private Book mBook;
    private Chapter mChapter;
    private LastChapter mLastChapter;
    private List<Verse> mVerseList;
    private List<Integer> mVersesWithNotesList;

    private CaretListener mCaretListener = new CaretListener() {
        @Override
        public void caretUpdate(CaretEvent e) {
            Document doc = jTextPane1.getDocument();

            Element rootElement = doc.getDefaultRootElement();
            int verse = rootElement.getElementIndex(e.getDot()) + 1;

            showNoteForVerse(verse);
        }
    };

    private void showNoteForVerse(int verse) {
        System.out.println("NoteFrame for Selected verse: " + mChapter.getChapterNumber() + ": " + verse);
        NoteFrame nf = NoteFrame.instance(mBook, mChapter, verse);

        //System.out.println("ChapterFrame: " + getBounds());
        Rectangle rect = getBounds();
        
        nf.setLocation(rect.x + rect.width + 5, rect.y);
        nf.setVisible(true);
    }

    public ChapterFrame(Book book) {
        mBook = new Book(book);
        
        initComponents();
        mVersesWithNotesList = new ArrayList<Integer>();

        mLastChapter = LastChapter.query(mBook.getId());

        mChapter = Chapter.query(mBook, mLastChapter.getChapter());
        mVersionId = mLastChapter.getVersionId();

        //System.out.println("Version id: " + mVersionId);
        versionButton.setText(Version.get(mVersionId).getAbbreviation());

        mExecutor = Executors.newFixedThreadPool(1);    // 5 may be more than needed

        jTextPane1.addCaretListener(mCaretListener);
        update();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        filler1 = new javax.swing.Box.Filler(new java.awt.Dimension(6, 0), new java.awt.Dimension(6, 0), new java.awt.Dimension(6, 32767));
        previousButton = new javax.swing.JButton();
        nextButton = new javax.swing.JButton();
        versionButton = new javax.swing.JButton();
        chaptersButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        filler2 = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0));
        progressBar = new javax.swing.JProgressBar();

        jButton1.setText("jButton1");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 45, Short.MAX_VALUE)
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        previousButton.setText("Previous");
        previousButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                previousButtonActionPerformed(evt);
            }
        });

        nextButton.setText("Next");
        nextButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextButtonActionPerformed(evt);
            }
        });

        versionButton.setText("NIV");
        versionButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                versionButtonActionPerformed(evt);
            }
        });

        chaptersButton.setText("Chapters");
        chaptersButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                chaptersButtonActionPerformed(evt);
            }
        });

        jTextPane1.setFont(new java.awt.Font("Lucida Sans", 0, 24)); // NOI18N
        jScrollPane1.setViewportView(jTextPane1);

        progressBar.setIndeterminate(true);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(versionButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(chaptersButton))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(previousButton)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, 313, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(35, 35, 35)
                                .addComponent(filler2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                        .addComponent(nextButton)))
                .addContainerGap())
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(versionButton)
                    .addComponent(chaptersButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 564, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(nextButton)
                    .addComponent(previousButton)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(filler2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        setBounds(0, 0, 563, 763);
    }// </editor-fold>//GEN-END:initComponents

    private void previousButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_previousButtonActionPerformed
        mChapter = mChapter.previous();
        update();
    }//GEN-LAST:event_previousButtonActionPerformed

    private void nextButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextButtonActionPerformed
        mChapter = mChapter.next();
        update();
    }//GEN-LAST:event_nextButtonActionPerformed

    private void versionButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_versionButtonActionPerformed
        mVersionId = Version.getNext(mVersionId);
        System.out.println("Next version id: " + mVersionId);
        versionButton.setText(Version.get(mVersionId).getAbbreviation());
        mLastChapter.setVersionId(mVersionId);
        update();
    }//GEN-LAST:event_versionButtonActionPerformed

    private void chaptersButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_chaptersButtonActionPerformed
        ChaptersDialog cd = new ChaptersDialog(mBook, this);
        cd.setLocationRelativeTo(this);
        cd.setVisible(true);
    }//GEN-LAST:event_chaptersButtonActionPerformed

    @Override
    public void chapterSelected(int chapter) {
        System.out.println("Select chapter " + chapter);
        mChapter = Chapter.query(mBook, chapter);
        update();
    }

    private void update() {
        mLastChapter.setChapter(mChapter.getChapterNumber());
        mLastChapter.update();
        
        progressBar.setVisible(true);
        progressBar.setIndeterminate(true);
        progressBar.setValue(0);

        // GetVerses does the local look up first
        mExecutor.execute(new GetVerses(mVersionId, mChapter, this));
    }

    @Override
    public void getVersesFinished(List<Verse> list) {
        System.out.println("ChapterFrame.getVersesFinished");
        mVerseList = list;
        updateUI();
        int first = mChapter.getVerseId();
        int last = first + mChapter.getVerses();

        mExecutor.execute(new GetNotesForChapter(first, last, this));
    }

    @Override
    public void getNotesForChapterFinished(List<Integer> list, boolean done) {
        mVersesWithNotesList = list;

        DefaultStyledDocument doc = (DefaultStyledDocument) jTextPane1.getDocument();
        Element rootElement = doc.getDefaultRootElement();

        for (Iterator<Integer> iterator = list.iterator(); iterator.hasNext();) {
            int verse = iterator.next() - mChapter.getVerseId();
            //System.out.println("ChapterFrame.getNotesForChapterFinished verse " + verse);
            Element element = rootElement.getElement(verse);
            Element e1 = element.getElement(0);
            int len = e1.getEndOffset() - e1.getStartOffset();
            doc.setCharacterAttributes(e1.getStartOffset(), len, sVerseWithNote, true);
        }

        // save the notes that are not already present
        // for existing notes, do the hard work of comparing
        progressBar.setIndeterminate(false);
        progressBar.setValue(progressBar.getMaximum());
        progressBar.setVisible(false);
    }

    @Override
    public void getNoteFinished(int verseId) {
        System.out.println("ChapterFrame.getNoteFinished " + verseId);
        // note has already been saved
    }

    private void updateUI() {
        int iChapter = mChapter.getChapterNumber();
        nextButton.setVisible(iChapter + 1 <= mBook.getChapters());
        nextButton.setText("Chapter " + (iChapter + 1));

        previousButton.setVisible(iChapter - 1 != 0);
        previousButton.setText("Chapter " + (iChapter - 1));

        mLastChapter.setChapter(iChapter);
        int nrows = mLastChapter.update();

        //System.out.println("last chapter updated " + nrows + " rows");
        //System.out.println(mLastChapter);
        setTitle(mBook.getName() + " " + iChapter);

        StyledDocument doc = new DefaultStyledDocument();

        int offset = 0;
        try {
            for (Verse v : mVerseList) {
                int verse = v.getVerse();
                //System.out.println("ChapterFrame.updateUI verse: " + verse);
                String txt = verse + " ";

                doc.insertString(offset, txt, sVerseWithoutNote);
                offset += txt.length();

                doc.insertString(offset, v.getText() + "\n", sVerseText);
                offset += v.getText().length() + 1;
            }
        } catch (BadLocationException e) {

        }

        // If I don't remove the listener I get a spurious NoteFrame created.
        jTextPane1.removeCaretListener(mCaretListener);
        jTextPane1.setDocument(doc);
        jTextPane1.addCaretListener(mCaretListener);

        //System.out.println("ChapterFrame.updateUI done");
    }

    @Override
    public String toString() {
        return "[ChapterFrame " + mChapter.toString() + "]";
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton chaptersButton;
    private javax.swing.Box.Filler filler1;
    private javax.swing.Box.Filler filler2;
    private javax.swing.JButton jButton1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextPane jTextPane1;
    private javax.swing.JButton nextButton;
    private javax.swing.JButton previousButton;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JButton versionButton;
    // End of variables declaration//GEN-END:variables

}
