package com.kgdsoftware.bible;

import com.kgdsoftware.bible.model.Book;
import com.kgdsoftware.bible.model.Chapter;
import com.kgdsoftware.bible.model.Note;
import com.kgdsoftware.bible.model.Setting;
import java.awt.Font;
import java.awt.event.MouseEvent;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

/**
 *
 * @author henriwarren
 *
 * Any remote notes have already been gotten by the ChapterFrame. Therefore,
 * NoteFrame is only creating notes or changing notes. These are the cases where
 * a POST is necessary.
 */
public class NoteFrame extends javax.swing.JFrame implements PostNote.Finished {

    private static SimpleDateFormat sDF = new SimpleDateFormat("MMM dd, yyy HH:mm");

    private static List<NoteFrame> sNoteFrameList = new ArrayList<>();
    private static long expired = 1000 * 60 * 60 * 6; // expires in 6 hours

    private static ExecutorService mExecutor;
    private static ScheduledExecutorService mMonitor;

    static {
        mExecutor = Executors.newFixedThreadPool(2);

        mMonitor = Executors.newSingleThreadScheduledExecutor();
        mMonitor.scheduleWithFixedDelay(new UpdateNotes(), 1, 10, TimeUnit.SECONDS);
    }

    private Book mBook;
    private Chapter mChapter;
    private int mVerse;
    private Note mNote;
    private boolean mNoteChanged;

    /**
     * Creates new form NoteFrame
     */
    private NoteFrame(Book book, Chapter chapter, int verse) {
        mBook = new Book(book);
        mChapter = new Chapter(chapter);
        mVerse = verse;
        mNoteChanged = false;

        initComponents();

        String fontName = Setting.getString("FontName", "Lucida Grande");
        int fontSize = Setting.getInt("FontSize", 18);
        int fontStyle = Setting.getInt("FontStyle", Font.BOLD);

        Font font = new Font(fontName, fontStyle, fontSize);
        noteTextArea.setFont(font);

        System.out.println("NoteFrame constructor " + mChapter.getChapterNumber() + ":" + mVerse);

        // get a local copy or create a new note
        mNote = Note.query(book, chapter, verse);

        noteTextArea.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void removeUpdate(DocumentEvent e) {
                //System.out.println("NoteFrame removeUpdate " + e.toString());
                mNoteChanged = true;
            }

            @Override
            public void insertUpdate(DocumentEvent e) {
                //System.out.println("NoteFrame insertUpdate " + e.toString());
                mNoteChanged = true;
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                //System.out.println("NoteFrame changedUpdate" + e.toString());
                mNoteChanged = true;
            }
        });

        updateUI();
    }

    public static NoteFrame instance(Book book, Chapter chapter, int verse) {
        for (NoteFrame nf : sNoteFrameList) {
            System.out.println("check: " + nf.getBook().getId() + " " + nf.getChapter().getChapterNumber() + ":" + nf.getVerse());
        }
        
        for (NoteFrame nf : sNoteFrameList) {
            System.out.println("check: " + nf.getBook().getId() + " " + nf.getChapter().getChapterNumber() + ":" + nf.getVerse());
            System.out.println(" with: " + book.getId() + " " + chapter.getChapterNumber() + ":" + verse);

            if ((nf.getBook().getId() == book.getId())
                    && (nf.getChapter().getChapterNumber() == chapter.getChapterNumber())
                    && (nf.getVerse() == verse)) {
                nf.toFront();
                nf.repaint();
                System.out.println("NoteFrame reuse existing NoteFrame " + chapter.getChapterNumber() + ":" + verse);
                return nf;
            }
        }

        System.out.println("NoteFrame a new NoteFrame");
        NoteFrame noteFrame = new NoteFrame(book, chapter, verse);
        sNoteFrameList.add(noteFrame);
        return noteFrame;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        popupMenu = new javax.swing.JPopupMenu();
        clearRemoteTimestamp = new javax.swing.JMenuItem();
        jScrollPane1 = new javax.swing.JScrollPane();
        noteTextArea = new javax.swing.JTextArea();
        previousVerse = new javax.swing.JButton();
        nextVerse = new javax.swing.JButton();
        remoteTimestampLabel = new javax.swing.JLabel();
        localTimestampLabel = new javax.swing.JLabel();
        saveRemoteButton = new javax.swing.JButton();
        saveLocalButton = new javax.swing.JButton();

        clearRemoteTimestamp.setText("Clear Remote Timestamp");
        clearRemoteTimestamp.setToolTipText("");
        clearRemoteTimestamp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearRemoteTimestampActionPerformed(evt);
            }
        });
        popupMenu.add(clearRemoteTimestamp);

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        noteTextArea.setColumns(20);
        noteTextArea.setLineWrap(true);
        noteTextArea.setRows(5);
        noteTextArea.setTabSize(2);
        noteTextArea.setWrapStyleWord(true);
        noteTextArea.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                noteTextAreaMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                noteTextAreaMouseReleased(evt);
            }
        });
        jScrollPane1.setViewportView(noteTextArea);

        previousVerse.setText("Verse");
        previousVerse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                previousVerseActionPerformed(evt);
            }
        });

        nextVerse.setText("Verse");
        nextVerse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextVerseActionPerformed(evt);
            }
        });

        remoteTimestampLabel.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        remoteTimestampLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        remoteTimestampLabel.setText("remote timestamp");

        localTimestampLabel.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        localTimestampLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        localTimestampLabel.setText("local timestamp");

        saveRemoteButton.setText("save Remote");
        saveRemoteButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveRemoteButtonActionPerformed(evt);
            }
        });

        saveLocalButton.setText("Save Local");
        saveLocalButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveLocalButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(previousVerse)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(remoteTimestampLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 183, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(saveRemoteButton)
                .addGap(18, 18, Short.MAX_VALUE)
                .addComponent(saveLocalButton)
                .addGap(18, 18, 18)
                .addComponent(localTimestampLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(nextVerse)
                .addContainerGap())
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 408, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(previousVerse)
                    .addComponent(nextVerse)
                    .addComponent(remoteTimestampLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 16, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(localTimestampLabel)
                    .addComponent(saveRemoteButton)
                    .addComponent(saveLocalButton))
                .addGap(14, 14, 14))
        );

        setBounds(0, 0, 860, 521);
    }// </editor-fold>//GEN-END:initComponents

    private void updateUI() {
        noteTextArea.setText(mNote.getText());
        mNoteChanged = false;   // It has not changed from what is in the note

        nextVerse.setText("Verse " + (mVerse + 1));
        nextVerse.setVisible((mVerse + 1) <= mChapter.getVerses());
        previousVerse.setText("Verse " + (mVerse - 1));
        previousVerse.setVisible((mVerse - 1 != 0));

        String title = mBook.getName() + " " + mChapter.getChapterNumber() + ":" + mVerse;
        setTitle(title + ((Bible.sPostingEnabled) ? "" : " (Local)"));

        long time = mNote.getLocalTimestamp();  // time in milliseconds
        String sTime = (time == 0) ? "no local time" : sDF.format(new Date(time));
        localTimestampLabel.setText(sTime);

        time = mNote.getRemoteTimestamp();      // time in seconds
        sTime = (time == 0) ? "no remote time" : sDF.format(new Date(time * 1000));
        remoteTimestampLabel.setText(sTime);
    }

    @Override
    public void postNoteFinished(int verseId) {
        // Either the note was updated or inserted.
        // In other words, the note exists, but I need to get it out of the local database
        try {
            System.out.println("NoteFrame.postNoteFinished: " + verseId);
            Note note = Note.query(verseId);
            note.update();             // update the local database
            if (mNote.getVerseId() == note.getVerseId()) {
                mNote = note;
                updateUI();
            }
        } catch (SQLException ex) {
            Logger.getLogger(NoteFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public Book getBook() {
        return mBook;
    }

    public Chapter getChapter() {
        return mChapter;
    }

    public int getVerse() {
        return mVerse;
    }

    public Note getNote() {
        return mNote;
    }

    private void saveNote(boolean remote) {
        System.out.println("NoteFrame.saveNote " + mNote.getText().length() + " characters in note");

//        if (mNoteChanged) {
        mNote.setText(noteTextArea.getText());
        if (mNote.isEmpty()) {
            mNote.delete();
            System.out.println("NoteFrame.saveNote note is empty");
        } else {
            mNote.update();
            if (remote) {
                mExecutor.execute(new PostNote(mNote, this));
            }
        }
//        } else {
//            if (mNote.isEmpty()) {
//                // query if you want to delete the note on the server
//                mNote.delete();
//                System.out.println("NoteFrame.saveNote note is empty");
//            }
//        }
    }

    private void previousVerseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_previousVerseActionPerformed
        saveNote(Bible.sPostingEnabled);
        if (mVerse > 1) {
            mVerse--;
        }
        mNote = Note.query(mBook, mChapter, mVerse);
        updateUI();
    }//GEN-LAST:event_previousVerseActionPerformed

    private void nextVerseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextVerseActionPerformed
        saveNote(Bible.sPostingEnabled);
        if (mVerse < mChapter.getVerses()) {
            mVerse++;
        }
        mNote = Note.query(mBook, mChapter, mVerse);
        updateUI();
    }//GEN-LAST:event_nextVerseActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        // save the note because this window is going away
        System.out.println("NoteFrame windowClosing\n");
        saveNote(Bible.sPostingEnabled);
    }//GEN-LAST:event_formWindowClosing

    private void saveLocalButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveLocalButtonActionPerformed
        // TODO add your handling code here:
        saveNote(false);
        mNoteChanged = false;
    }//GEN-LAST:event_saveLocalButtonActionPerformed

    private void saveRemoteButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveRemoteButtonActionPerformed
        // TODO add your handling code here:
        saveNote(true);
        mNoteChanged = false;
    }//GEN-LAST:event_saveRemoteButtonActionPerformed

    private void clearRemoteTimestampActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearRemoteTimestampActionPerformed
        mNote.setRemoteTimestamp(0);
        saveNote(false);    // local save only
        mNoteChanged = false;
        updateUI();
    }//GEN-LAST:event_clearRemoteTimestampActionPerformed

    private void noteTextAreaMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_noteTextAreaMousePressed
        if (evt.isPopupTrigger()) {
            showPopupMenu(evt);
        }
    }//GEN-LAST:event_noteTextAreaMousePressed

    private void noteTextAreaMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_noteTextAreaMouseReleased
        if (evt.isPopupTrigger()) {
            showPopupMenu(evt);
        }
    }//GEN-LAST:event_noteTextAreaMouseReleased

    private void showPopupMenu(MouseEvent e) {
        popupMenu.show(this, e.getX(), e.getY());
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem clearRemoteTimestamp;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel localTimestampLabel;
    private javax.swing.JButton nextVerse;
    private javax.swing.JTextArea noteTextArea;
    private javax.swing.JPopupMenu popupMenu;
    private javax.swing.JButton previousVerse;
    private javax.swing.JLabel remoteTimestampLabel;
    private javax.swing.JButton saveLocalButton;
    private javax.swing.JButton saveRemoteButton;
    // End of variables declaration//GEN-END:variables

    public static class UpdateNotes implements Runnable, PostNote.Finished {
        @Override
        public void run() {
            Note note = Note.queryLocalOnly();
            if (note != null) {
                mExecutor.execute(new PostNote(note, this));
            } else {
                System.out.println("note query returned null????");
                mMonitor.shutdownNow();
            }
        }

        @Override
        public void postNoteFinished(int verseId) {
            System.out.println("NoteFrame.UpdateNotes.postNoteFinished: " + verseId);
            // note was already updated locally (in the parse method)
        }
    }
}
